# Внутренняя работа HashMap в Java
[Внутренняя работа HashMap в Java](https://habr.com/ru/post/421179/)

# Рекурсия
*Рекурсия (recursion)* - ситуация при которой метод, прямо или косвенно , вызывает сам себя. При этом говорят, что метод *рекурсивный*    
*Базовый случай* -условие, при котором рекурсивный метод не вызывает себя, а завершает своё выполнение тем самым обеспечивая *выход из рекурсии*  
*Глубина рекурсии* - количество рекурсивных вызовов до наступления *базового случая*  
## Пример рекурсивного метод
~~~java
public class Main {
    public static void main(String[] args) {
        recursionMethod(0,3);
    }

    public static void recursionMethod(int i, int target ){
        if (i==target){        //  базовый случай
            System.out.println("   Базовый случай. i="+i + " Цель достигнута. Завершаем");
        } else {              //   рекурсивный случай
            System.out.println("Старт: ("+i+")");
            recursionMethod(i+1,target);     // рекурсивный вызов метода
            System.out.println("Финиш: ("+i+")");
        }
    }
}
~~~
Вывод:
~~~
Старт: (0)
Старт: (1)
Старт: (2)
   Базовый случай. i=3 Цель достигнута. Завершаем.
Финиш: (2)
Финиш: (1)
Финиш: (0)
~~~

В примере выше i принимает значения от 0 до 3. Метод recursionMethod() вызывается каждый раз с новым, увеличенным на 1 значением i. *Базовый случай -* i достигло значения 3. Обратите внимание, что все вызовы начинают завершаться только после достижения *базового случая*.

Конечно, данный код может быть легко заменен циклом, но иногда замена рекурсивного алгоритма циклическим достаточно трудоемка.

## Недостатки рекурсивных алгоритмов
 Основная проблема рекурсивных алгоритмов - требовательность к размеру стека и, как следствие, высокая вероятность StackOverflowError при большой *глубине рекурсии*.

 